<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Boost Filesystem Library</title>
</head>

<body bgcolor="#FFFFFF">

<h1><IMG SRC="../../c++boost.gif" WIDTH="276" HEIGHT="86" align="center">Boost 
Filesystem Library</h1>
<p><a href="#Introduction">Introduction</a><br>
<a href="#Motivation">Motivation</a><br>
<a href="#Portability">Portability Cautions</a><br>
<a href="#Reference">Reference</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Overview">Overview</a><br>
&nbsp;&nbsp;&nbsp; <a href="#Definitions">Definitions</a><br>
&nbsp;&nbsp;&nbsp; <a href="#DirectorySynopsis">Header 
&lt;boost/filesystem/directory.hpp&gt; Synopsis</a><br>
&nbsp;&nbsp;&nbsp; <a href="#PathSynopsis">Header &lt;boost/filesystem/path.hpp&gt; 
Synopsis</a><br>
<a href="design.htm">Design</a><br>
&nbsp;&nbsp;&nbsp; <a href="design.htm#Requirements">Requirements</a><br>
&nbsp;&nbsp;&nbsp; <a href="design.htm#Realities">Realities</a><br>
&nbsp;&nbsp;&nbsp; <a href="design.htm#Rationale">Rationale FAQ</a><br>
&nbsp;&nbsp;&nbsp; <a href="design.htm#Acknowledgements">Acknowledgements</a></p>
<h2><a name="Introduction">Introduction</a></h2>
<p>The Boost Filesystem Library provides facilities to portably query and 
manipulate directories, files, and directory or file paths.</p>
<p>For example, this program will delete all the directories within the current 
working directory whose names begins with &quot;temp_&quot;:</p>
<blockquote>
  <pre>#include &lt;boost/filesystem/directory.hpp&gt;
#include &lt;string&gt;
namespace fs = boost::filesystem;

int main()
{
  for ( fs::directory_iterator itr( fs::initial_directory() ), end_itr;
        itr != end_itr; ++itr )
    if ( itr-&gt;is_directory() &amp;&amp; itr-&gt;name().substr( 0, 5 ) == &quot;temp_&quot; )
      fs::remove_all( itr-&gt;path() );
  return 0;
}</pre>
</blockquote>
<h2><a name="Motivation">Motivation</a></h2>
<p>The motivation for the library is the common need to be able to perform 
simple, portable, script-like operations from within C++ programs. The intent is not to 
compete with Python, Perl, or shell languages, but rather to provide portable file system 
operations when C++ is already the language of choice.</p>
<h2><a name="Portability">Portability</a> Cautions</h2>
<p>The Filesystem Library has been designed for portable operations between 
hierarchical file systems, and, with some care, can also be portable between 
flat file systems with no notion of directory trees.</p>
<p>File, directory, and path names are, however, inherently non-portable.&nbsp; 
A file name like &quot;<code>passwords.txt</code>&quot; may be invalid on file systems 
which do not support lowercase letters, or do not have a concept of file extension, 
or do not allow periods in file names, or do not support file names of that long. [<b>TODO</b>: 
add some guidelines for composing relatively portable names.]</p>
<p>The representation of paths is even more problematic; a path like &quot;<code>mydir/myfile.txt</code>&quot; 
only works on POSIX or Windows-like operating systems which accept &quot;<code>/</code>&quot; 
as a path separator.&nbsp; The &lt;boost/filesystem/path.hpp&gt; header provides more 
portable ways to specify paths.</p>
<h2><a name="Reference">Reference</a></h2>
<h3><a name="Overview">Overview</a></h3>
<p>The <a href="../../boost/filesystem/directory.hpp">
&lt;boost/filesystem/directory.hpp&gt;</a> header (see <a href="#DirectorySynopsis">
synopsis</a>) provides operations on files, and possibly directories.&nbsp;The
<a href="../../boost/filesystem/path.hpp">&lt;boost/filesystem/path.hpp&gt;</a> header 
(see <a href="#PathSynopsis">synopsis</a>)&nbsp; provides operations on path 
strings used to identify files and directories.</p>
<p>The relationship between directories and files can be viewed as a tree, or 
hierarchy, with the branches being non-empty directories and the leaves being 
either files or empty directories. Thus directories may contain 
files, and possibly directories, but are not themselves considered files.</p>
<p>On some platforms, files may represent &quot;special&quot; concepts like socket or 
device, but they are still considered files. </p>
<blockquote>
<p><i>Guidance for implementors:</i> If an operating system normally views 
devices, pipes, sockets, connections, or other operating system objects as files 
(as does POSIX), and can open them using the stdio or fstream file I/O 
facilities, then these should be be treated by the filesystem library as files; 
they should be found by directory iteration, and can be named in paths. If the 
operating system does not view such objects as files, the filesystem library 
should not treat them as files, directory iteration should not find such 
objects, and it is undefined behavior for the user to use them in paths, except 
in implementation defined ways.</p>
</blockquote>
<h3><a name="Definitions">Definitions</a></h3>
<p><b><a name="directory">directory</a> </b>- a operating system provided 
container holding files, and, possibly, directories. Directories are identified 
by <a href="#directory path">directory path</a>.</p>
<p><b><a name="path">path</a> </b>- A string whose contents identify a file or 
directory to the operating system by specifying some portion of a directory 
tree. The string is composed of elements naming each node in the tree, but the 
exact syntax of the representation is implementation defined. For some operating 
systems, there are multiple valid paths which can identify any given file or 
directory. Unless otherwise specified, paths may be either
<a href="#absolute path">absolute</a> or <a href="#relative path">relative</a>.</p>
<p><b><a name="file path">file path</a></b> - A <a href="#path">path</a> 
identifying a file. Note that a file path can be as simple as a
<a href="#file name">file name</a>.</p>
<p><b><a name="directory path">directory path</a></b> - A <a href="#path">path</a> 
identifying a directory. Note that a directory path can be as simple as a
<a href="#directory name">directory name</a>.</p>
<p><b><a name="absolute path">absolute path</a></b> - A fully specified
<a href="#path">path</a> uniquely identifying a file or directory to the 
operating system.</p>
<p><b><a name="relative path">relative path</a></b> - A <a href="#path">path</a> 
which is to be interpreted by the operating system as beginning from some 
implicit parent directory.</p>
<p><b><a name="name">name</a></b> - A file or directory name without
<a href="#directory path">directory path</a> information indicating which 
directory (or directories), if any, may contain entries with that name. For some 
operating systems, files and directories may have more than one valid name 
string.</p>
<p><b><a name="file name">file name</a></b> - A string containing a
<a href="#name">name</a> of a file.</p>
<p><b><a name="directory name">directory name</a></b> - A string containing&nbsp; 
a <a href="#name">name</a> of a directory.</p>
<h2>Header <a href="../../boost/filesystem/directory.hpp">
&lt;boost/filesystem/directory.hpp&gt;</a> <a name="DirectorySynopsis">Synopsis</a></h2>
<pre>namespace boost
{
  namespace filesystem
  {
    bool <a href="#exists">exists</a>( const std::string &amp; path );
    bool <a href="#is_directory">is_directory</a>( const std::string &amp; path );
    bool <a href="#is_file">is_file</a>( const std::string &amp; path );
    bool <a href="#empty">empty</a>( const std::string &amp; path );
#if !defined(BOOST_MSVC) || _MSC_VER &gt; 1300 // VC++ 7.0 or earlier
    inline bool <a href="#is_empty">is_empty</a>( const std::string &amp; path ) { return empty( path ); }
#endif
    void <a href="#create_directory">create_directory</a>( const std::string &amp; directory_path );
    void <a href="#remove_file">remove_file</a>( const std::string &amp; file_path );
    void <a href="#remove_directory">remove_directory</a>( const std::string &amp; directory_path );
    unsigned long <a href="#remove_all">remove_all</a>( const std::string &amp; path );
    void <a href="#rename">rename</a>( const std::string &amp; from_path,
                 const std::string &amp; to_path );
    void <a href="#copy_file">copy_file</a>( const std::string &amp; from_file_path,
                    const std::string &amp; to_file_path );
    const std::string &amp; <a href="#initial_directory">initial_directory</a>();

    class directory_entry
    {
    public:
      // default constructor, copy constructor, copy assignment, and
      // destructor with usual semantics

      bool is_directory() const; // may be cached
      bool is_file() const { return !is_directory(); }
      const std::string &amp; name() const;
      const std::string &amp; directory_path() const;
      const std::string &amp; path() const;
    };

    class directory_iterator
    {
    public:
      typedef directory_entry  value_type;

      directory_iterator(); // creates the &quot;end&quot; iterator
      explicit directory_iterator( const std::string &amp; directory_path );
      ~directory_iterator();
      bool operator==( const directory_iterator &amp; ) const;

      // other members as required to meet InputIterator requirements;
    };

  } // namespace filesystem
} // namespace boost
</pre>
<h3><a name="Requirements">Requirements</a></h3>
<p>Unless otherwise specified:</p>
<ul>
  <li>The internal syntactic form of path arguments is unspecified. The 
  expectation is simply that an implementation support the usual syntax for the 
  operating system. The <a href="#PathSynopsis">boost/filesystem/path.hpp header</a> 
  provides portable ways to manipulate paths.<br>
&nbsp;</li>
  <li>The semantics of particular internal syntactic forms of path arguments is 
  unspecified. Path arguments may represent absolute paths, or relative paths, 
  if relative paths are supported by the operating system. The expectation is 
  simply that an implementation support the usual semantics for the operating 
  system.<br>
&nbsp;</li>
  <li>Any function may throw if an argument is not well-formed.<br>
&nbsp;</li>
  <li>Path arguments of an empty string are not well-formed.<br>
&nbsp;</li>
  <li>In addition to cases specified in the specific &quot;Throws&quot; paragraph for a 
  function, all functions will throw if the operating system cannot successfully 
  complete the indicated operation. There is no rollback guarantee; a failed 
  operation may leave the external file system in an altered the state.</li>
</ul>
<h3><a name="Caution">Caution</a></h3>
<p>The state of files and directories is often <a href="design.htm#global">
globally shared</a>, and thus may be changed unexpectedly by other threads, 
processes, or even other computers which have access to a file system. As an 
example of the difficulties this can cause, consider that the following asserts 
may fail:</p>
<blockquote>
<p><code>assert( exists( &quot;foo&quot; ) == exists( &quot;foo&quot; ) );&nbsp; // #1<br>
<br>
remove_all( &quot;foo&quot; );<br>
assert( !exists( &quot;foo&quot; ) );&nbsp; // #2<br>
<br>
assert( is_directory( &quot;foo&quot; ) == is_directory( &quot;foo&quot; ) ); // #3</code></p>
</blockquote>
<p>Number 1 will fail if a non-existent &quot;foo&quot; comes into existence, or an 
existent &quot;foo&quot; is removed, between the first and second call to <i>exists()</i>. 
This could happen if, during the execution of the example code, another thread, 
process, or computer is also performing operations in the same directory.</p>
<p>Number 2 will fail if between the call to <i>remove_all()</i> and the call to
<i>exists()</i> a new file or directory named &quot;foo&quot; is created by another 
thread, process, or computer.</p>
<p>Number 3 will fail if another thread, process, or computer removes an 
existing file &quot;foo&quot; and then creates a directory named &quot;foo&quot;, between the 
example code's two calls to <i>is_directory()</i>.</p>
<p>A program which needs to be robust when operating on potentially shared file 
or directory resources should be prepared for <i>filesystem_error</i> exceptions 
to be thrown from any filesystem operation except those explicitly specified as 
not throwing exceptions.</p>
<h2>Directory Header Non-member Functions</h2>
<h3><a name="exists">exists</a></h3>
<blockquote>
<p><code>bool exists( const std::string &amp; path );</code></p>
<p><b>Returns:</b> True if the operating system reports the file or directory 
represented by <i>path</i> exists, else false.</p>
<p><b>Note: </b>Even if exists( path ) == true, there is no guarantee that it 
will be possible to perform other operations on the file or directory. Access 
rights or other security concerns, for example, may cause other operations to 
fail.</p>
</blockquote>
<h3><a name="is_directory">is_directory</a></h3>
<blockquote>
<p><code>bool is_directory( const std::string &amp; path );</code></p>
<p><b>Returns:</b> True if<i> path</i> represents a directory, else false.</p>
<p><b>Throws:</b> if <code>!exists(path)</code></p>
</blockquote>
<h3><a name="is_file">is_file</a></h3>
<blockquote>
<p><code>bool is_file( const std::string &amp; path );</code></p>
<p><b>Returns:</b> True if<i> path</i> represents a file, else false.</p>
<p><b>Throws:</b> if <code>!exists(path)</code></p>
<p><b>Rationale:</b> Although logically just <i>!is_directory( path )</i>, 
specifying <i>is_file()</i> as a separate function allow more explicit user 
code, and allows implementations to provide more explicit error messages. </p>
</blockquote>
<h3><a name="empty">empty</a></h3>
<blockquote>
<p><code>bool empty( const std::string &amp; path );</code></p>
<p>Synonym for <i>is_empty()</i>. Provided as a workaround for a Microsoft VC++ 
7.0 and earlier bug that causes a name clash between the <i>boost::is_empty</i> 
type trait and <i>boost::filesystem::is_empty</i>.</p>
</blockquote>
<h3><a name="is_empty">is_empty</a></h3>
<blockquote>
<p><code>bool is_empty( const std::string &amp; path );</code></p>
<p><b>Returns:</b> True if<i> path</i> represents an empty file or directory, else false.</p>
<p><b>Throws:</b> if <code>!exists(path)</code></p>
</blockquote>
<h3><a name="create_directory">create_directory</a></h3>
<blockquote>
<p><code>void create_directory( const std::string &amp; directory_path );</code></p>
<p><b>Postcondition:</b> <code>exists(directory_path) &amp;&amp; 
is_directory(directory_path) &amp;&amp; is_empty(directory_path)</code></p>
<p><b>Throws: </b>if <code>exists(directory_path)) || !exists(branch(directory_path))</code></p>
</blockquote>
<h3><a name="remove_file">remove_file</a></h3>
<blockquote>
<p><code>void remove_file( const std::string &amp; file_path );</code></p>
<p><b>Postcondition:</b> <code>!exists( file_path )</code></p>
<p><b>Throws:</b> if <code>!exists(file_path) || !is_file(file_path)</code></p>
</blockquote>
<h3><a name="remove_directory">remove_directory</a></h3>
<blockquote>
<p><code>void remove_directory( const std::string &amp; directory_path );</code></p>
<p><b>Postcondition:</b> <code>!exists( directory_path )</code></p>
<p><b>Throws:</b> if <code>!exists(directory_path) || !is_directory(directory_path) 
|| !is_empty(directory_path)</code></p>
</blockquote>
<h3><a name="remove_all">remove_all</a></h3>
<blockquote>
<p><code>unsigned long remove_all( const std::string &amp; path );</code></p>
<p><b>Postcondition:</b> <code>!exists( path )</code></p>
<p><b>Returns:</b> The number of files and directories removed.</p>
</blockquote>
<h3><a name="rename">rename</a></h3>
<blockquote>
<p><code>void rename( const std::string &amp; from_path, const std::string &amp; to_path 
);</code></p>
<p><b>Effects:</b> Changes the name of&nbsp; file or directory <i>from_path</i> 
to <i>to_path</i>.</p>
<p><b>Postconditions:</b> <code>!exists(from_path) &amp;&amp; exists(to_path)</code>, 
and the file or directory contents and attributes are otherwise unchanged.</p>
<p><b>Throws:</b> if <code>!exists(from_path) || exists(to_path) || !exist(branch(to_path))</code></p>
<p><b>Note:</b> <i>rename</i> is effectively the same operation as <i>move</i>.</p>
<p><b>Note:</b> if <code>branch(from_path)</code> resolves to the same directory 
as <code>branch(to_path)</code>, then <code>leaf(from_path)</code> must not be 
the same name as <code>leaf(to_path)</code>, but if the branch directories are 
different, it doesn't matter if the leaf names are the same.</p>
<p><b>Rationale:</b> For not having separate <i>rename_file()</i>, <i>
rename_directory()</i>, and <i>rename()</i> functions: existing practice, lack 
of apparent benefit other than consistency, safety arguments not as strong as 
with the <i>remove</i> family. For name: <i>rename</i> is traditional with both 
C, C++, and POSIX.</p>
</blockquote>
<h3><a name="copy_file">copy_file</a></h3>
<blockquote>
<p><code>void copy_file( const std::string &amp; from_file_path, const std::string &amp; 
to_file_path );</code></p>
<p><b>Effects:</b> Copies the file represented by <i>from_file_path</i> to <i>
to_file_path</i>.</p>
<p><b>Throws:</b> if <code>!exists(from_file_path) || !is_file(from_file_path) 
|| exists(to_path) || !exist(branch(to_path))</code></p>
</blockquote>
<h3><a name="initial_directory">initial_directory</a></h3>
<p><code>const std::string &amp; initial_directory();</code></p>
<p><b>Effects:</b> The first time the function is called, it stores an absolute 
directory path.</p>
<p>The preferred effect is to store the initial working directory path when <i>
main()</i> was called. Implementations are permitted, however, to store the 
current working directory. If neither of these actions is possible, a diagnostic 
is required.</p>
<p><b>Returns:</b> The stored path.</p>
<p><b>Rationale:</b>&nbsp; The semantics, in effect, turn a global variable into 
a safer global constant. The preferred implementation requires runtime-library 
support, so alternate semantics are supplied for those implementations which 
cannot change an existing the runtime-library.</p>
<p><b>Note:</b> It would be good practice in a program dependent on <i>
initial_directory()</i> to call it immediately upon entering<i> main()</i>. That 
protects against some other called function altering the current working 
directory (using a native platform function) before the first call to <i>
initial_directory()</i>.</p>
<h2>Header <a href="../../boost/filesystem/path.hpp">&lt;boost/filesystem/path.hpp&gt;</a>
<a name="PathSynopsis">Synopsis</a></h2>
<p>Still in development.</p>
<hr>
<p>© Beman Dawes, 2002</p>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->17 May, 2002<!--webbot bot="Timestamp" endspan i-checksum="13977" --></p>
<p>&nbsp;</p>

</body>

</html>