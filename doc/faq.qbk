[/
 / Copyright Andrey Semashev 2024.
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at
 / https://www.boost.org/LICENSE_1_0.txt)
 /]

[section:faq Frequently Asked Questions]

[section:general General questions]

[heading Why not support a concept of specific kinds of file systems, such as posix_file_system or windows_file_system?]

Portability is one of the most important requirements for the library. Features specific to a particular operating system
or file system can always be accessed by using the operating system's API.

[endsect]

[section:path Class `path` questions]

[heading Why base the generic pathname format on POSIX?]

[link filesystem.design.references.posix-01 POSIX] is an ISO Standard. It is the basis for the most familiar pathname formats,
not just for POSIX-based operating systems but also for Windows and the URL portion of URIs. It is ubiquitous and familiar.
On many systems, it is very easy to implement because it is either the native operating system format (Unix and Windows) or
via an operating system supplied POSIX library (z/OS, OS/390, and many more.)

[heading Why not use a full URI (Universal Resource Identifier) based path?]

[link filesystem.design.references.uri URIs] would promise more than the Filesystem Library can actually deliver, since URIs
extend far beyond what most operating systems consider a file or a directory. Thus for the primary "portable script-style file
system operations" requirement of the Filesystem Library, full URIs appear to be over-specification.

[heading Why isn't `path` a base class with derived `directory_path` and `file_path` classes?]

Why bother? The behavior of all three classes is essentially identical. Several early versions did require users to identify
each path as a file or directory path, and this seemed to increase coding errors and decrease code readability. There was no
apparent upside benefit.

[heading Why do path decomposition functions yielding a single element return a path rather than a string?]

Interface simplicity. If they returned strings, flavors would be needed for different string and character types.

[heading Why don't `path` member functions have overloads with `error_code&` arguments?]

They have not been requested by users; the need for error reporting via `error_code` seems limited to filesystem operation
failures rather than path failures.

[endsect]

[section:operations Operations function questions]

[heading Why not supply a 'handle' type, and let the file and directory operations traffic in it?]

It isn't clear there is any feasible way to meet the "portable script-style file system operations" requirement with such
a system. File systems exist where operations are usually performed on some non-string handle type. The classic Mac OS has been
mentioned explicitly as a case where trafficking in paths isn't always natural.

The case for the "handle" (opaque data type to identify a file) style may be strongest for directory iterator value type. (See
Jesse Jones' Jan 28, 2002, Boost postings). However, as class `path` has evolved, it seems sufficient even as the directory
iterator value type.

[heading Why are the operations functions so low-level?]

To provide a toolkit from which higher-level functionality can be created.

An extended attempt to add convenience functions on top of, or as a replacement for, the low-level functionality failed because
there is no widely acceptable set of simple semantics for most convenience functions considered. Attempts to provide alternate
semantics via either run-time options or compile-time polices became overly complicated in relation to the value delivered,
or became contentious. On the other hand, the specific functionality needed for several trial applications was very easy for
the user to construct from the lower-level toolkit functions. See [link filesystem.design.abandoned_designs Failed Attempts].

[heading Isn't it inconsistent then to provide a few convenience functions?]

Yes, but experience with both this library, POSIX, and Windows, indicates the utility of certain convenience functions, and
that it is possible to provide simple, yet widely acceptable, semantics for them. For example, `remove_all()`.

[heading Why are there `directory_entry` overloads for `operations.hpp` predicate functions? Isn't two ways to do the same
thing poor design?]

Yes, two ways to do the same thing is often a poor design practice. But the `directory_entry` versions are often much more
efficient. Calling `status()` during iteration over a directory containing 15,000 files took 6 seconds for the path overload,
and 1 second for the `directory_entry` overload, for tests on a freshly booted machine. Times were .90 seconds and .30 seconds,
for tests after prior use of the directory. This performance gain is large enough to justify deviating from preferred design
practices. Neither overload alone meets all needs.

[heading Why are the operations functions so picky about errors?]

Safety. The default is to be safe rather than sorry. This is particularly important given the reality that on many computer
systems files and directories are globally shared resources, and thus subject to race conditions.

[heading Why are attributes accessed via named functions rather than property maps?]

For commonly used attributes (existence, directory or file, emptiness), simple syntax and guaranteed presence outweigh other
considerations. Because access to many other attributes is inherently system dependent, property maps are viewed as the best hope
for access and modification, but it is better design to provide such functionality in a separate library. (Historical note:
even the apparently simple attribute "read-only" turned out to be so system dependent as to be disqualified as a "guaranteed
presence" operation.)

[heading Why isn't automatic name portability error detection provided?]

A number (at least six) of designs for name validity error detection were evaluated, including at least four complete
implementations. While the details for rejection differed, all of the more powerful name validity checking designs distorted
other otherwise simple aspects of the library. Even the simple name checking provided in prior library versions was a constant
source of user complaints. While name checking can be helpful, it isn't important enough to justify added a lot of additional
complexity.

[heading Why are paths sometimes manipulated by member functions and sometimes by non-member functions?]

The design rule is that purely lexical operations are supplied as class `path` member functions, while operations performed
by the operating system are provided as free functions.

[endsect]

[endsect]
