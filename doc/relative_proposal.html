<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Filesystem Relative Proposal</title>
<link href="styles.css" rel="stylesheet">
</head>

<body>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td width="277">
<a href="../../../index.htm">
<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" width="300" height="86" border="0"></a></td>
    <td align="middle">
    <font size="7">Filesystem Relative Proposal</font>
    </td>
  </tr>
</table>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
 bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
  <tr>
    <td><a href="index.htm">Home</a> &nbsp;&nbsp;
    <a href="tutorial.html">Tutorial</a> &nbsp;&nbsp;
    <a href="reference.html">Reference</a> &nbsp;&nbsp;
    <a href="faq.htm">FAQ</a> &nbsp;&nbsp;
    <a href="release_history.html">Releases</a> &nbsp;&nbsp;
    <a href="portability_guide.htm">Portability</a> &nbsp;&nbsp;
    <a href="v3.html">V3 Intro</a> &nbsp;&nbsp;
    <a href="v3_design.html">V3 Design</a> &nbsp;&nbsp;
    <a href="deprecated.html">Deprecated</a> &nbsp;&nbsp;
    <a href="issue_reporting.html">Bug Reports </a>&nbsp;&nbsp;
    </td>
</table>

<h2>
      Introduction</h2>

<p>
      The request for new functionality seems simple - given two paths with a 
      common prefix, return the non-common suffix portion of one of the paths 
      such that it is relative to the other path.</p>

<p>
      In terms of the Filesystem library,</p>

<blockquote>
  <pre>path p(&quot;/a/b/c/d&quot;);
path base(&quot;/a/b&quot;);
path rel = relative(p, base);      // relative is the requested function
assert(absolute(rel, base) == p); </pre>
</blockquote>
<p>If it were that simple, the Filesystem library would have had a <code>
relative</code> function right from the start.</p>
<p>Considerations include:</p>
<ul>
  <li>Some uses require symlinks be followed; i.e. the path must be resolved in 
  the actual file system.</li>
  <li>Some uses require symlinks not be followed; i.e. the path must not be 
  resolved in the actual file system.</li>
  <li>Some uses require removing redundant current directory (<i>dot</i>) 
  or parent directory (<i>dot-dot</i>) placeholders.</li>
  <li>Some uses require not removing redundant current directory (<i>dot</i>) 
  or parent directory (<i>dot-dot</i>) placeholders.</li>
  <li>Some uses never have redundant current directory (<i>dot</i>) 
  or parent directory (<i>dot-dot</i>) placeholders, so a removal operation 
  would be an unnecessary expense although otherwise harmless.</li>
  <li>In some uses <code>p</code> and <code>base</code> are themselves relative.</li>
  <li>What happens if there is no common prefix? Is this an error, the whole of
  <code>p</code> is relative to <code>base</code>, or something else?</li>
  <li>What happens if <code>p</code>, <code>base</code>, or both are empty?</li>
  <li>What happens if <code>p</code> and <code>base</code> are the same?</li>
  <li>How is the &quot;common prefix&quot; determined?</li>
  <li>What happens if portions of <code>p</code> or <code>base</code> exist but 
  the entire path does not exist and yet symlinks need to be followed?</li>
  <li>What happens when a symlink in the existing portion of a path is affected 
  by a directory (<i>dot-dot</i>) placeholder in a later non-existent portion of 
  the path?</li>
</ul>

<h2>
      Design</h2>

<h2>
      Design decisions</h2>

<h4>
      Provide<b> a set of functions that &quot;just work&quot;</b></h4>

<p>
      &nbsp;</p>

<h4 dir="ltr" align="left">
      Provide<b> separate <a href="#lex-relative">lexically </a></b><code>
      <a href="#lex-relative">relative</a></code><b> and <a href="#op-relative">
      operationally </a></b><code><a href="#op-relative">relative</a></code><b> 
      functions</b></h4>

<p>
      A purely lexical function is needed by users working with directory 
      hierarchies that do not actually exist.</p>

<p>
      An operational function that queries the current file system for existence 
      and follows symlinks is needed by users working with actual existing 
      directory hierarchies.</p>

<h4>
      Provide<b> </b>a class path member function <code><a href="#normal">normal</a></code> returning a 
      <a href="#normal-form">normalized</a> path</h4>

<p>
      &quot;Normalization&quot; is the process of removing redundant current directory (<i>dot</i>) and parent 
      directory (<i>dot-dot</i>) elements.</p>

<p>
      Normalization is a byproduct the current <code>canonical</code> function. 
      But for the path returned by the 
      proposed <code><a href="#weakly_canonical">weakly_canonical</a></code> function, 
      only any leading canonic portion is in canonical form. So any trailing 
      portion of the returned path has not been normalized.</p>

<p>
      Jamie Allsop has proposed adding a separate normalization function returning a 
      path, and I agree with him.</p>

<p>
      Boost.filesystem has a deprecated non-const normalization function that 
      modifies the path, but I agree with Jamie that a function returning 
      a path is a better solution. The name <code>normal</code> avoids clashing 
      with the deprecated (but still present) <code>path::normalize</code> name.</p>

<h4>
      Provide<b> </b>a <code><a href="#weakly_canonical">weakly_canonical</a></code> operational function</h4>

<p>
      The weakly (i.e. weakened requirements) canonical operational function
      <code>weakly_canonical(p)</code> returns a path composed of <code>
      canonical(x)/y</code>, where <code>x</code> is a path composed of the 
      longest leading sequence of elements in <code>p</code> that exists, and
      <code>y</code> is a path composed of the remaining trailing elements of
      <code>p</code> if any.</p>

<ul>
  <li>Having <code>weakly_canonical</code> as a separate function, and then 
  specifying the processing of operational <code>relative</code> arguments in 
  terms of calls to <code>weakly_canonical</code> makes it much easier to 
  specify the operational <code>relative</code> function and reason about it. 
  The difficulty of reasoning about operational <code>relative</code> 
  semantics before the invention of <code>weakly_canonical</code> was what led to its 
  initial development.</li>
  <li>Having <code>weakly_canonical</code> as a separate function also allows 
  use in other contexts.</li>
</ul>

<h4 dir="ltr">
      Specify lexical <code>relative</code> to &quot;just work&quot; for users</h4>

<ul>
  <li>Useful, detectable semantics when either or both paths are empty, and when 
  all elements of the two paths match exactly.</li>
  <li>Work with both relative and absolute <code>*this</code> and argument paths.</li>
</ul>

<h4>
      Specify operational <code><a href="#op-relative">relative</a></code> in terms of <code>
      <a href="#weakly_canonical">weakly_canonical</a></code></h4>

<ul>
  <li>Covers a much wider range of uses cases since a single function works for 
  existing, non-existing, and partially existing paths.</li>
  <li>Works correctly for partially existing paths that contain simlinks.</li>
</ul>

<h4>
      Specify operational <code><a href="#op-relative">relative</a></code> in terms of lexical <code>
      <a href="#lex-relative">relative</a></code></h4>

<p>
      If would be confusing to users and difficult to specify correctly if the 
      two functions have differing semantics:</p>
<ul>
  <li>When either or both paths are empty.</li>
  <li>When all elements of the two paths match exactly.</li>
  <li>Because different matching algorithms were used.</li>
  <li>Because although the same matching algorithm was used, it was applied in different ways.</li>
</ul>

<p>
      These problems are avoided by specifying the operational <code>relative</code> 
      in terms of a call to the <code>lexical</code> relative after preparatory 
      calls to operational functions.</p>

<h2>Proposed wording</h2>

<h3>Define a new term</h3>

<p>A path is in <b><i><a name="normal-form">normal form</a></i></b> if it has no 
redundant current directory (<i>dot</i>) and (<i>dot-dot</i>) directory parent 
elements. The normal form for an empty path is an empty path. The normal form 
for a path ending in a <i>directory-separator</i> that is not the root directory 
is the same path with a current directory (<i>dot</i>) element appended.</p>

<h3>New class path member functions</h3>

<p>The&nbsp; <code><a href="#normal">normal</a></code> and <code>
<a href="#lex-relative">relative</a></code> member functions, like all member functions of class <code>path</code>, perform lexical processing 
only. They do not 
follow symlinks.</p>

<p>These semantics are useful for operating on paths that do not currently exist 
or on paths generated by operational non-member functions that resolve symlinks.</p>

<pre>path <a name="normal">normal</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> <code>*this</code> in <a href="#normal-form">normal form</a>.</p>
<p><i>Remarks:</i> Uses <code>operator/=</code> to compose the returned path.</p>
<p>[<i>Example:</i></p>
<p><code>assert(path(&quot;foo/./bar/..&quot;).normal() == &quot;foo&quot;);<br>
assert(path(&quot;foo/./bar/../&quot;).normal() == &quot;foo/.&quot;);</code></p>
<p dir="ltr">All of the above assertions will succeed.<i> </i>On Windows, the 
returned path&#39;s <i>directory-separator</i> characters will be backslashes rather than slashes, but that 
does not affect <code>path</code> equality.<i> —end example</i>]</p>
</blockquote>

<pre>path <a name="lex-relative">relative</a>(const path&amp; base) const;</pre>
<blockquote>
  
  <p><i>Returns:</i> </p>
  
  <ul>
    <li>
  <p><code>path()</code> if the first mismatched element of <code>
  *this</code> is equal to <code>begin()</code> and the first mismatched element 
  of <code>base</code> is equal to <code>&nbsp;base.begin()</code>, or<br>
&nbsp;</p>
  
    </li>
    <li>
  <p><code>path(&quot;.&quot;)</code> if the first mismatched element of <code>
  *this</code> is equal to <code>end()</code> and the first mismatched element 
  of base is equal to <code>base.end()</code>, or<br>
&nbsp;</p>
  
    </li>
    <li>An object of class <code>path</code> composed via application of <code>
    operator/= path(&quot;..&quot;)</code> for each element in the sequence [first 
    mismatched element of <code>base</code>, <code>base.end()</code>), and then 
    application of <code>operator/=</code> for each element in the sequence 
    [first mismatched element of <code>p</code>, <code>p.end()</code>).</li>
</ul>
  <p><i>Remarks:</i> Uses <code>std::mismatch(begin(), end(), 
  base.begin(), base.end())</code> to determine the first mismatched element. 
  Path equality is determined by <code>operator==</code>. </p>
  
<p>[<i>Example:</i></p>
<p><code>assert(path(&quot;/a/d&quot;).relative(&quot;/a/b/c&quot;) ==  &quot;../../d&quot;);<br>
assert(path(&quot;/a/b/c&quot;).relative(&quot;/a/d&quot;) ==  &quot;../b/c&quot;);<br>
assert(path(&quot;a/b/c&quot;).relative(&quot;a&quot;) == &quot;b/c&quot;);<br>
assert(path(&quot;a/b/c&quot;).relative(&quot;a/b/c/x/y&quot;) ==  &quot;../..&quot;);<br>
assert(path(&quot;a/b/c&quot;).relative(&quot;a/b/c&quot;) ==  &quot;.&quot;);</code></p>
<p dir="ltr">All of the above assertions will succeed.<i> </i>On Windows, the 
returned path&#39;s <i>directory-separator</i>s will be backslashes rather than 
forward slashes, but that 
does not affect <code>path</code> equality.<i> —end example</i>]</p>
  
  <p>[<i>Note:</i> If symlink following semantics are desired, use the non-member operational function <code>
  <a href="#op-relative">relative</a></code>&nbsp; <i>—end note</i>]</p>
  
  <p>[<i>Note:</i> Call <code><a href="#normal">normal()</a></code> on <code>*this</code>, <code>base</code>, 
  or both, if <a href="#normal">normalization</a> is needed to ensure consistent matching of 
  elements. <i>—end note</i>]</p>
  
</blockquote>
<h3>New operational functions</h3>
<pre>path <a name="weakly_canonical">weakly_canonical</a>(const path&amp; p);
path weakly_canonical(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
<i>Returns: </i>
<p dir="ltr"><code>exists(p)<br>
&nbsp; ? canonical(p)<br>
&nbsp; : (p.parent_path().empty()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
? p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: <a href="#weakly_canonical">weakly_canonical</a>(p.parent_path())/p.filename()</code>.</p>
<p><i>Postcondition:</i> The returned path is in <a href="#normal">normal form</a>.</p>
<p><i>Remarks:</i> Implementations are permitted to use iteration 
rather than recursion. Implementations are encouraged to avoid unnecessary 
normalization such as when <code>canonical</code> has already been called on the 
entire returned path.</p>
<p><i>Throws:</i>&nbsp; As specified in Error reporting.</p>
</blockquote>
<pre>path <a name="op-relative">relative</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
<p><i>Returns:</i> <code>relative(p, current_path(), ec)</code>.</p>
  <p><i>Throws:</i>&nbsp; As specified in Error reporting.</p>
  
  </blockquote>
<pre>path relative(const path&amp; p, const path&amp; base=current_path());
path relative(const path&amp; p, const path&amp; base, system::error_code&amp; ec);</pre>
<blockquote>
<p><i>Returns:</i> <code><a href="#weakly_canonical">weakly_canonical</a>(p).<a href="#lex-relative">relative</a>(<a href="#weakly_canonical">weakly_canonical</a>(base))</code>. The second form returns <code><span style="font-size: 85%">
path()</span></code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in Error reporting.</p>
</blockquote>

<hr>
<p>© Copyright Beman Dawes 2015</p>
<p>Distributed under the Boost Software License, Version 1.0. See
<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->15 August 2015<!--webbot bot="Timestamp" endspan i-checksum="31423" --></p>

</body>

</html>