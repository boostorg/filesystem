<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Filesystem Library Design</title>
</head>

<body bgcolor="#FFFFFF">

<h1><IMG SRC="../../c++boost.gif" WIDTH="276" HEIGHT="86" align="center">Boost Filesystem Library Design</h1>

<h2><a name="Requirements">Requirements</a></h2>
<ul>
  <li>Be able to write portable script-style file system operations in modern 
  C++.<br>
  <br>
  Rationale: This is a common programming need. It is both an 
  embarrassment and a hardship that this is not possible with either the current 
  C++ Standard Library or Boost libraries.&nbsp; The need is particularly acute 
  when C++ is the only toolset allowed in the tool chain.&nbsp; File system 
  operations are provided by many languages&nbsp; used on multiple platforms, 
  such as Perl and Python, as well as by many platform's native scripting 
  languages. <br>
&nbsp;</li>
  <li>Work within the <a href="#Realities">realities</a> described below.<br>
  <br>
  Rationale: This isn't a research project. We need something that works on 
  today's platforms, including some of the smaller embedded operating systems 
  with limited file systems. Because of the emphasis on portability, such a 
  library would be much more useful if standardized. That means being able to 
  work with a much wider range of platforms that just Unix or Windows and their 
  clones.<br>
&nbsp;</li>
  <li>Avoid dangerous programming practices. For example, global state data and 
  too-easy-to-ignore error notifications.&nbsp; If a dangerous feature is provided, identify it as such.<br>
  <br>
  Rationale: Usually this would be covered by &quot;the usual Boost requirements...&quot;, 
  but it is mentioned explicitly because the equivalent native platform and 
  scripting language interfaces often depend on global state like &quot;current 
  working directory&quot; and too-easy-to-ignore error notifications.<br>
&nbsp;</li>
  <li>Structure the library so that it is still useful even if some functionality 
  does not map well onto a given platform or directory tree. Particularly, much 
  useful functionality should be portable even to flat 
(non-hierarchical) file systems.<br>
  <br>
  Rationale: Much functionality which does not 
  require a hierarchical directory structure is still useful on flat-structure 
  file systems.&nbsp; There are many systems, particularly embedded systems, 
  where even very limited functionality is still useful.</li>
</ul>
<ul>
  <li>Support multiple file systems within a program, and file systems which 
  change characteristics at different locations within a directory tree.<br>
  <br>
  Rationale:&nbsp;This is really just fallout from the <a href="#Realities">
  realities</a>.</li>
</ul>
<ul>
  <li>Interface smoothly with current C++ Standard Library input/output 
  facilities.&nbsp; For example, <a href="#filepath">file paths</a> should be 
  easy to use in std::basic_fstream constructors.<br>
  <br>
  Rationale: One of the most common uses of file system functionality is to 
  manipulate path and file names for eventual use in input/output operations.&nbsp; 
  Thus these names should interface smoothly with standard library I/O.<br>
&nbsp;</li>
  <li>Suitable for eventual standardization. The implication of this requirement 
  is that the interface be close to minimal, and that many details (For example, 
  &quot;what are the valid characters in a filename?&quot;) be unspecified.<br>
  <br>
  Rationale: The lack of file system operations is a serious hole 
  in the current standard, and no other known candidates to fill that hole. 
  Libraries with elaborate interfaces and difficult to port specifications are much less likely to be accepted for 
  standardization.<br>
&nbsp;</li>
  <li>The usual Boost requirements for any library also apply.</li>
</ul>
<h2><a name="Realities">Realities</a></h2>
<ul>
  <li>On many platforms, the native file system interface is nothing like what 
  would be designed today if starting from scratch.&nbsp; For example, state is 
  often global rather than associated with particular objects.<br>
&nbsp;</li>
  <li>Some file systems are single rooted, others are multi-rooted.<br>
&nbsp;</li>
  <li>Some file systems provide both a long and short form of filenames.<br>
&nbsp;</li>
  <li>Some file systems (ISO-9660 for CD-ROM's, for example) use very restricted 
  (so-called 8.3) file names.<br>
&nbsp;</li>
  <li>Some file systems allow other file systems with completely different 
  characteristics to be &quot;mounted&quot; within a directory tree.&nbsp; Thus a 
  ISO-9660 or Windows 
  file system may end up as a sub-tree of a Unix directory tree.<br>
&nbsp;</li>
  <li>Wide-character versions of operations are available on some operating 
  systems, and not available on others.<br>
&nbsp;</li>
  <li>There is no law that says directory hierarchies have to be specified in 
  terms of left-to-right decent from the root.<br>
&nbsp;</li>
  <li>Some file systems have a concept of file &quot;version number&quot; or &quot;generation 
  number&quot;.&nbsp; Some don't.<br>
&nbsp;</li>
  <li>Not all file systems use single separators in path names.&nbsp; Some use 
  paired notations. A typical fully-specified VMS filename
  might look something like this:<br>
  <br>
  <code>&nbsp;&nbsp; DISK$SCRATCH:[GEORGE.PROJECT1.DAT]BIG_DATA_FILE.NTP;5<br>
  </code><br>
  The general format is:<br>
  <br>
&nbsp;&nbsp;&nbsp;&nbsp; 
  Device:[directories.dot.separated]filename.extension;version_number<br>
&nbsp;</li>
  <li>For common file systems, determining if two descriptors are for same 
  entity is extremely difficult or impossible.&nbsp; For example, the concept of 
  equality can be different for each portion of a path - some portions may be 
  case or locale sensitive, others not. Case sensitivity is a property of the 
  pathname itself, and not the platform. Determining collating sequence is even 
  worse.<br>
&nbsp;</li>
  <li>Directory trees, directories, files, and file attributes are in effect 
  <a name="global">shared</a> between all threads, processes, and computers which have access to the 
  file system.&nbsp; That may well include computers on the other side of the 
  world or in orbit around the world. This implies that file system operations 
  may fail in unexpected ways.&nbsp; For example:<br>
  <br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; assert( exists(&quot;foo&quot;) == exists(&quot;foo&quot;) ); 
  // may fail!<br>
&nbsp;&nbsp;&nbsp;&nbsp; assert( is_directory(&quot;foo&quot;) == is_directory(&quot;foo&quot;); 
  // may fail!<br>
  </code><br>
  In the first example, the file may have been deleted between calls to 
  exists().&nbsp; In the second example, the file may have been deleted and then 
  replaced by a directory of the same name between the calls to is_directory().</li>
</ul>
<h2>Design</h2>
<p>The design given here mentions only fundamental operations which cannot be 
further decomposed.&nbsp; Additional operations, composed from the fundamental 
operations, may be supplied by the actual library to improve ease-of-use, but 
subject to the &quot;close to minimal&quot; standardization requirement.</p>
<p>Many file systems have both absolute and relative forms of paths, 
particularly in hierarchical directory structure file systems.&nbsp;Unless otherwise 
specified,&nbsp; function arguments may use either the absolute or relative 
form.</p>
<p>Unless otherwise specified, operations throw exceptions if they do not 
complete successfully.</p>
<p>Descriptors (file system paths and names) are of type std::string.</p>
<h2><a name="Rationale">Rationale</a> FAQ</h2>
<p><b>Why not supply a 'path' type, and let the file and directory 
operations traffic in it?</b></p>
<ul>
  <li>As long as descriptors are simply strings, many operations &quot;just work&quot;, 
  resulting in a much simpler and familiar public interface.</li>
  <li>Using strings means that non-portable, but useful, operations are easy to 
  perform, yet don't clutter the interface with functions which only apply to 
  certain platforms.&nbsp; For example, functions to manipulate file extensions 
  (which are a very non-portable concept.)</li>
  <li>Several proposals have been made for a path type, with conversions to 
  and from strings. That's a sign paths are just strings.</li>
</ul>
<p>Each new type introduced has its costs. With costs a concern and benefits 
uncertain, the conservative approach is simply use std::string types.</p>
<p><b>Why not supply a 'handle' type, and let the file and directory operations 
traffic in it?</b></p>
<p>File systems exist where operations are usually performed on 
  some non-string handle type. The Mac was mentioned explicitly as a case where 
trafficking in string descriptors isn't always natural.&nbsp; It isn't clear 
there is any feasible way to meet the &quot;portable script-style file system 
operations&quot; requirement with such a system.&nbsp; </p>
<p>Note that the case for the &quot;handle&quot; (opaque data type to identify a file) 
style may be stronger for directory iterators to return a handle than for some 
of the other functions to traffic in handles.&nbsp; (See Jesse Jones' Jan 28, 
2002, postings).</p>
<p><b>Why not use a URI (Universal Resource Identifier) based path?</b></p>
<p>Since URI's can conveniently be represented as strings, URI manipulations can 
be layered on top of a string based approach. Thus trafficking in strings does 
not preclude URI's.&nbsp; But for the primary &quot;portable script-style file system 
operations&quot; requirement, URI's appear over-specification.</p>
<p><b>Why not support a more general concept of file system, supporting 
http_file_system or posix_file_system for example?</b></p>
<p>A major requirement for a file system library is to work with the current 
standard's I/O file open and construction. Since the standard doesn't provide 
for any other kinds of files beyond whatever the operating system considers to 
be a file, it seems to be over-design to provide for URL's and the like as an 
explicit part of this library.<br>
<br>
Also, as several people pointed out in design discussions, concepts like &quot;posix_file_system&quot; 
are very slippery. What happens when a NTFS or ISO 9660 file system is mounted 
in directory on a POSIX machine, for example?</p>
<p><b>Why support paths only as std::string?&nbsp; Why not std::wstring or even 
a templated type?</b></p>
<p>The standards committee's Library Working Group has discussed this in some 
detail both on the committee's library reflector and at the Cura<font face="Times New Roman">çao 
meeting</font>, and feels that (1) names based on types other than char are 
extremely non-portable, (2) there is no agreed upon semantics for conversion 
between wstring and string for file systems which do not support wstring, and 
(3) even the most committee members (like Dietmar) most supportive of wstring 
names are unsure that they are a good idea in the context of the standard.</p>
<p><b>Why aren't directories considered to be files?</b></p>
<p>The filesystem library does not consider directories to be files since 
directories cannot portably and usefully be opened using the C++ Standard Library stdio or fstream file I/O facilities. An important additional rationale is that 
separating the concept of directories and files makes exposition and 
specification clearer.</p>
<p><b>Why are the non-member functions so low-level?</b></p>
<p>To provide a toolkit from which higher-level functionality can be created. An 
extended attempt to add convenience functions on top of, or as a replacement 
for, the low-level functionality failed because there is no widely acceptable 
set of simple semantics for most convenience functions considered.&nbsp; 
Attempts to provide alternate semantics, via either run-time options or 
compile-time polices, became overly complicated in relation to the value 
delivered, or became contentious.&nbsp; OTOH, the specific functionality needed for several trial 
applications was very easy for the user to construct from the lower-level 
toolkit functions.&nbsp; See <a href="#Failed Attempts">Failed Attempts</a>.</p>
<p><b>Isn't it inconsistent then to provide a few convenience functions?</b></p>
<p>Yes, but experience with both this library, and POSIX and Windows, indicates 
the utility of certain convenience functions, and that it is possible to provide 
simple, yet widely acceptable, semantics for them. For example, remove_all.</p>
<p><b>Why are the free functions so picky about errors?</b></p>
<p>Safety. The default is to be safe rather than sorry. This is particularly 
important given the reality that on many computer systems files and directories 
are <a href="#global">globally shared</a> resources .</p>
<p><b>Why are errors reported by exception rather than return code or error 
notification variable?</b></p>
<p>Safety.&nbsp;Return codes or error notification variables are often ignored 
by programmers.&nbsp; Exceptions are much harder to ignore, provided desired 
default behavior (program termination) if not caught, yet allow error recovery 
if desired.</p>
<p><b>Why are attributes accessed and modified via named functions rather than
<a href="../property_map/property_map.html">property maps</a>?</b></p>
<p>For a few commonly used attributes (existence, directory or file, emptiness), 
simple syntax and guaranteed presence outweigh other considerations. Because 
access to virtually all other attributes is inherently system dependent, 
property maps are viewed as the best hope for access and modification, but it is 
better design to provide such functionality in a separate library. (Historical 
note: even the apparently simple attribute &quot;read-only&quot; turned out to be so 
system depend as to be disqualified as a &quot;guaranteed presence&quot; operation.)</p>
<p><b>Why aren't there query functions for multiple conditions like 
is_existing_directory()?</b></p>
<p>After several attempts, multi-attribute named queries proved a 
slippery-slope; where do you stop? (Note: this argument is much weakened now 
that the significant queries are reduced to <i>exists</i> and <i>
is_/directory/file/</i>. Consider adding <i>is_existing_directory()</i> and <i>
is_existing_file()</i>; ignore<i> is_empty</i> as less commonly useful.)</p>
<h2><a name="Failed Attempts">Failed Attempts</a></h2>
<p>Previous iterations of the design used explicitly named functions providing a 
large number of convenience operations, with no compile-time or run-time 
options. There were so many function names that they were very confusing to use, 
and the interface was much larger. Any benefits seemed theoretical rather than 
real. </p>
<p>Designs based on compile time (rather than runtime) flag and option selection 
(via policy, enum, or int template parameters) became so complicated that they 
were abandoned, often after investing quite a bit of time and effort. The need 
to qualify attribute or option names with namespaces, even aliases, made use in 
template parameters ugly; that wasn't fully appreciated until actually writing 
real code.</p>
<p>Yet another set of convenience functions ( for example, <i>remove</i> with 
permissive, prune, recurse, and other options, plus predicate, and possibly 
other, filtering features) were abandoned because the details became both 
complex and contentious. What is left is a toolkit of low-level operations from 
which the user can create more complex convenience operations, plus a very small 
number of convenience functions which were found to be useful enough to justify 
inclusion.</p>
<hr>
<h2><a name="Acknowledgements">Acknowledgements</a></h2>
<p>This design is based in part on prior work from Dietmar Kühl and Jan Langer, and 
extensive discussions on the Boost mailing list..&nbsp; Participants included 
(in chronological order through February, 2002) Jan Langer, Darin Adler, Michiel 
Salters, Jani Kajala, Jason Stewart, Carl Daniel, David Abrahams, Bill Kempf, 
Jonathan Caves, George Heintzelman, Ken Hagen, Eric Jensen, Joel de Guzman, Jim 
Hyslop, John Maddock, Matt Austern, Peter Dimov, Davlet Panech, Dylan, and 
others.</p>

<p>Specific improvements for this document came from Dan Nuffer and Jeff 
Garland.</p>

<hr>
<p>Revised:
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%B %d, %Y" startspan -->May 14, 2002<!--webbot bot="Timestamp" endspan i-checksum="11109" --></p>
<p>© Beman Dawes, 2002.</p>

</body>

</html>